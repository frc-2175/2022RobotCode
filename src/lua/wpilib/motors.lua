-- Automatically generated by bindings.c. DO NOT EDIT.

local ffi = require("ffi")
require("wpilib.bindings.asserts")
require("wpilib.bindings.enum")

---@class VictorSPX
---@field _this VictorSPX
VictorSPX = {}

---@class TalonSRX
---@field _this TalonSRX
TalonSRX = {}

---@class TalonFX
---@field _this TalonFX
TalonFX = {}

---@class CANSparkMax
---@field _this CANSparkMax
CANSparkMax = {}

---@class SparkMaxRelativeEncoder
---@field _this SparkMaxRelativeEncoder
SparkMaxRelativeEncoder = {}

---@class DifferentialDrive
---@field _this DifferentialDrive
DifferentialDrive = {}

---@class CTREInvertType
---@field None integer
---@field InvertMotorOutput integer
---@field FollowMaster integer
---@field OpposeMaster integer
CTREInvertType = BindingEnum:new('CTREInvertType', {
    None = 0,
    InvertMotorOutput = 1,
    FollowMaster = 2,
    OpposeMaster = 3,
})

---@class CTRETalonFXInvertType
---@field CounterClockwise integer
---@field Clockwise integer
---@field FollowMaster integer
---@field OpposeMaster integer
CTRETalonFXInvertType = BindingEnum:new('CTRETalonFXInvertType', {
    CounterClockwise = 0,
    Clockwise = 1,
    FollowMaster = 2,
    OpposeMaster = 3,
})

---@class SparkMaxMotorType
---@field kBrushed integer
---@field kBrushless integer
SparkMaxMotorType = BindingEnum:new('SparkMaxMotorType', {
    kBrushed = 0,
    kBrushless = 1,
})

---@class IdleMode
---@field kCoast integer
---@field kBrake integer
IdleMode = BindingEnum:new('IdleMode', {
    kCoast = 0,
    kBrake = 1,
})

---@class SparkMaxEncoderType
---@field kNoSensor integer
---@field kHallSensor integer
---@field kQuadrature integer
SparkMaxEncoderType = BindingEnum:new('SparkMaxEncoderType', {
    kNoSensor = 0,
    kHallSensor = 1,
    kQuadrature = 2,
})

---@return any
function VictorSPX:toSpeedController()
    return ffi.C.VictorSPX_ToSpeedController(self._this)
end

---@param value number
---@return any
function VictorSPX:set(value)
    value = AssertNumber(value)
    ffi.C.VictorSPX_Set(self._this, value)
end

---@param output number
---@return any
function VictorSPX:setVoltage(output)
    output = AssertNumber(output)
    ffi.C.VictorSPX_SetVoltage(self._this, output)
end

---@return number
function VictorSPX:get()
    return ffi.C.VictorSPX_Get(self._this)
end

---@param isInverted boolean
---@return any
function VictorSPX:setInvertedBool(isInverted)
    ffi.C.VictorSPX_SetInvertedBool(self._this, isInverted)
end

---@return boolean
function VictorSPX:getInvertedBool()
    return ffi.C.VictorSPX_GetInvertedBool(self._this)
end

---@return any
function VictorSPX:disable()
    ffi.C.VictorSPX_Disable(self._this)
end

---@return any
function VictorSPX:stopMotor()
    ffi.C.VictorSPX_StopMotor(self._this)
end

---@return any
function VictorSPX:toIMotorController()
    return ffi.C.VictorSPX_ToIMotorController(self._this)
end

---@param mode integer
---@param value number
---@return any
function VictorSPX:setWithControlMode(mode, value)
    mode = AssertInt(mode)
    value = AssertNumber(value)
    ffi.C.VictorSPX_SetWithControlMode(self._this, mode, value)
end

---@param mode integer
---@param demand0 number
---@param demand1Type integer
---@param demand1 number
---@return any
function VictorSPX:setWithControlModeAndDemands(mode, demand0, demand1Type, demand1)
    mode = AssertInt(mode)
    demand0 = AssertNumber(demand0)
    demand1Type = AssertInt(demand1Type)
    demand1 = AssertNumber(demand1)
    ffi.C.VictorSPX_SetWithControlModeAndDemands(self._this, mode, demand0, demand1Type, demand1)
end

---@return any
function VictorSPX:neutralOutput()
    ffi.C.VictorSPX_NeutralOutput(self._this)
end

---@param neutralMode integer
---@return any
function VictorSPX:setNeutralMode(neutralMode)
    neutralMode = AssertInt(neutralMode)
    ffi.C.VictorSPX_SetNeutralMode(self._this, neutralMode)
end

---@param PhaseSensor boolean
---@return any
function VictorSPX:setSensorPhase(PhaseSensor)
    ffi.C.VictorSPX_SetSensorPhase(self._this, PhaseSensor)
end

---@param invertType integer
---@return any
function VictorSPX:setInverted(invertType)
    invertType = AssertEnumValue(CTREInvertType, invertType)
    invertType = AssertInt(invertType)
    ffi.C.VictorSPX_SetInverted(self._this, invertType)
end

---@return boolean
function VictorSPX:getInverted()
    return ffi.C.VictorSPX_GetInverted(self._this)
end

---@param timeoutMs? integer
---@return integer
function VictorSPX:configFactoryDefault(timeoutMs)
    timeoutMs = timeoutMs or 50
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigFactoryDefault(self._this, timeoutMs)
end

---@param secondsFromNeutralToFull number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configOpenloopRamp(secondsFromNeutralToFull, timeoutMs)
    timeoutMs = timeoutMs or 0
    secondsFromNeutralToFull = AssertNumber(secondsFromNeutralToFull)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigOpenloopRamp(self._this, secondsFromNeutralToFull, timeoutMs)
end

---@param secondsFromNeutralToFull number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configClosedloopRamp(secondsFromNeutralToFull, timeoutMs)
    timeoutMs = timeoutMs or 0
    secondsFromNeutralToFull = AssertNumber(secondsFromNeutralToFull)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigClosedloopRamp(self._this, secondsFromNeutralToFull, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configPeakOutputForward(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigPeakOutputForward(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configPeakOutputReverse(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigPeakOutputReverse(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configNominalOutputForward(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigNominalOutputForward(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configNominalOutputReverse(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigNominalOutputReverse(self._this, percentOut, timeoutMs)
end

---@param percentDeadband number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configNeutralDeadband(percentDeadband, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentDeadband = AssertNumber(percentDeadband)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigNeutralDeadband(self._this, percentDeadband, timeoutMs)
end

---@param voltage number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configVoltageCompSaturation(voltage, timeoutMs)
    timeoutMs = timeoutMs or 0
    voltage = AssertNumber(voltage)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigVoltageCompSaturation(self._this, voltage, timeoutMs)
end

---@param filterWindowSamples integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:configVoltageMeasurementFilter(filterWindowSamples, timeoutMs)
    timeoutMs = timeoutMs or 0
    filterWindowSamples = AssertInt(filterWindowSamples)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigVoltageMeasurementFilter(self._this, filterWindowSamples, timeoutMs)
end

---@param enable boolean
---@return any
function VictorSPX:enableVoltageCompensation(enable)
    ffi.C.VictorSPX_EnableVoltageCompensation(self._this, enable)
end

---@return boolean
function VictorSPX:isVoltageCompensationEnabled()
    return ffi.C.VictorSPX_IsVoltageCompensationEnabled(self._this)
end

---@return number
function VictorSPX:getBusVoltage()
    return ffi.C.VictorSPX_GetBusVoltage(self._this)
end

---@return number
function VictorSPX:getMotorOutputPercent()
    return ffi.C.VictorSPX_GetMotorOutputPercent(self._this)
end

---@return number
function VictorSPX:getMotorOutputVoltage()
    return ffi.C.VictorSPX_GetMotorOutputVoltage(self._this)
end

---@return number
function VictorSPX:getTemperature()
    return ffi.C.VictorSPX_GetTemperature(self._this)
end

---@param coefficient number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:configSelectedFeedbackCoefficient(coefficient, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    coefficient = AssertNumber(coefficient)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigSelectedFeedbackCoefficient(self._this, coefficient, pidIdx, timeoutMs)
end

---@param sensorTerm integer
---@param feedbackDevice integer
---@return integer
function VictorSPX:configSensorTerm(sensorTerm, feedbackDevice)
    sensorTerm = AssertInt(sensorTerm)
    feedbackDevice = AssertInt(feedbackDevice)
    return ffi.C.VictorSPX_ConfigSensorTerm(self._this, sensorTerm, feedbackDevice)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getSelectedSensorPosition(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetSelectedSensorPosition(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getSelectedSensorVelocity(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetSelectedSensorVelocity(self._this, pidIdx)
end

---@param sensorPos number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:setSelectedSensorPosition(sensorPos, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 50
    sensorPos = AssertNumber(sensorPos)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_SetSelectedSensorPosition(self._this, sensorPos, pidIdx, timeoutMs)
end

---@param frame integer
---@param periodMs integer
---@return integer
function VictorSPX:setControlFramePeriod(frame, periodMs)
    frame = AssertInt(frame)
    periodMs = AssertInt(periodMs)
    return ffi.C.VictorSPX_SetControlFramePeriod(self._this, frame, periodMs)
end

---@param enable boolean
---@return any
function VictorSPX:overrideLimitSwitchesEnable(enable)
    ffi.C.VictorSPX_OverrideLimitSwitchesEnable(self._this, enable)
end

---@param forwardSensorLimit number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configForwardSoftLimitThreshold(forwardSensorLimit, timeoutMs)
    timeoutMs = timeoutMs or 0
    forwardSensorLimit = AssertNumber(forwardSensorLimit)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigForwardSoftLimitThreshold(self._this, forwardSensorLimit, timeoutMs)
end

---@param reverseSensorLimit number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configReverseSoftLimitThreshold(reverseSensorLimit, timeoutMs)
    timeoutMs = timeoutMs or 0
    reverseSensorLimit = AssertNumber(reverseSensorLimit)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigReverseSoftLimitThreshold(self._this, reverseSensorLimit, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configForwardSoftLimitEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigForwardSoftLimitEnable(self._this, enable, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configReverseSoftLimitEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigReverseSoftLimitEnable(self._this, enable, timeoutMs)
end

---@param enable boolean
---@return any
function VictorSPX:overrideSoftLimitsEnable(enable)
    ffi.C.VictorSPX_OverrideSoftLimitsEnable(self._this, enable)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function VictorSPX:config_kP(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_Config_kP(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function VictorSPX:config_kI(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_Config_kI(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function VictorSPX:config_kD(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_Config_kD(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function VictorSPX:config_kF(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_Config_kF(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function VictorSPX:config_IntegralZone(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_Config_IntegralZone(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param allowableCloseLoopError number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configAllowableClosedloopError(slotIdx, allowableCloseLoopError, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    allowableCloseLoopError = AssertNumber(allowableCloseLoopError)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigAllowableClosedloopError(self._this, slotIdx, allowableCloseLoopError, timeoutMs)
end

---@param slotIdx integer
---@param iaccum number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configMaxIntegralAccumulator(slotIdx, iaccum, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    iaccum = AssertNumber(iaccum)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigMaxIntegralAccumulator(self._this, slotIdx, iaccum, timeoutMs)
end

---@param slotIdx integer
---@param percentOut number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configClosedLoopPeakOutput(slotIdx, percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigClosedLoopPeakOutput(self._this, slotIdx, percentOut, timeoutMs)
end

---@param slotIdx integer
---@param loopTimeMs integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:configClosedLoopPeriod(slotIdx, loopTimeMs, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    loopTimeMs = AssertInt(loopTimeMs)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigClosedLoopPeriod(self._this, slotIdx, loopTimeMs, timeoutMs)
end

---@param invert boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configAuxPIDPolarity(invert, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigAuxPIDPolarity(self._this, invert, timeoutMs)
end

---@param iaccum number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:setIntegralAccumulator(iaccum, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    iaccum = AssertNumber(iaccum)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_SetIntegralAccumulator(self._this, iaccum, pidIdx, timeoutMs)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getClosedLoopError(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetClosedLoopError(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getIntegralAccumulator(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetIntegralAccumulator(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getErrorDerivative(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetErrorDerivative(self._this, pidIdx)
end

---@param slotIdx integer
---@param pidIdx integer
---@return integer
function VictorSPX:selectProfileSlot(slotIdx, pidIdx)
    slotIdx = AssertInt(slotIdx)
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_SelectProfileSlot(self._this, slotIdx, pidIdx)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getClosedLoopTarget(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetClosedLoopTarget(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getActiveTrajectoryPosition(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetActiveTrajectoryPosition(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function VictorSPX:getActiveTrajectoryArbFeedFwd(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.VictorSPX_GetActiveTrajectoryArbFeedFwd(self._this, pidIdx)
end

---@param sensorUnitsPer100ms number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configMotionCruiseVelocity(sensorUnitsPer100ms, timeoutMs)
    timeoutMs = timeoutMs or 0
    sensorUnitsPer100ms = AssertNumber(sensorUnitsPer100ms)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigMotionCruiseVelocity(self._this, sensorUnitsPer100ms, timeoutMs)
end

---@param sensorUnitsPer100msPerSec number
---@param timeoutMs? integer
---@return integer
function VictorSPX:configMotionAcceleration(sensorUnitsPer100msPerSec, timeoutMs)
    timeoutMs = timeoutMs or 0
    sensorUnitsPer100msPerSec = AssertNumber(sensorUnitsPer100msPerSec)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigMotionAcceleration(self._this, sensorUnitsPer100msPerSec, timeoutMs)
end

---@param curveStrength integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:configMotionSCurveStrength(curveStrength, timeoutMs)
    timeoutMs = timeoutMs or 0
    curveStrength = AssertInt(curveStrength)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigMotionSCurveStrength(self._this, curveStrength, timeoutMs)
end

---@return integer
function VictorSPX:clearMotionProfileTrajectories()
    return ffi.C.VictorSPX_ClearMotionProfileTrajectories(self._this)
end

---@return integer
function VictorSPX:getMotionProfileTopLevelBufferCount()
    return ffi.C.VictorSPX_GetMotionProfileTopLevelBufferCount(self._this)
end

---@return boolean
function VictorSPX:isMotionProfileFinished()
    return ffi.C.VictorSPX_IsMotionProfileFinished(self._this)
end

---@return boolean
function VictorSPX:isMotionProfileTopLevelBufferFull()
    return ffi.C.VictorSPX_IsMotionProfileTopLevelBufferFull(self._this)
end

---@return any
function VictorSPX:processMotionProfileBuffer()
    ffi.C.VictorSPX_ProcessMotionProfileBuffer(self._this)
end

---@param timeoutMs? integer
---@return integer
function VictorSPX:clearMotionProfileHasUnderrun(timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ClearMotionProfileHasUnderrun(self._this, timeoutMs)
end

---@param periodMs integer
---@return integer
function VictorSPX:changeMotionControlFramePeriod(periodMs)
    periodMs = AssertInt(periodMs)
    return ffi.C.VictorSPX_ChangeMotionControlFramePeriod(self._this, periodMs)
end

---@param baseTrajDurationMs integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:configMotionProfileTrajectoryPeriod(baseTrajDurationMs, timeoutMs)
    timeoutMs = timeoutMs or 0
    baseTrajDurationMs = AssertInt(baseTrajDurationMs)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigMotionProfileTrajectoryPeriod(self._this, baseTrajDurationMs, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configMotionProfileTrajectoryInterpolationEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigMotionProfileTrajectoryInterpolationEnable(self._this, enable, timeoutMs)
end

---@param feedbackNotContinuous boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configFeedbackNotContinuous(feedbackNotContinuous, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigFeedbackNotContinuous(self._this, feedbackNotContinuous, timeoutMs)
end

---@param clearPositionOnLimitF boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configClearPositionOnLimitF(clearPositionOnLimitF, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigClearPositionOnLimitF(self._this, clearPositionOnLimitF, timeoutMs)
end

---@param clearPositionOnLimitR boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configClearPositionOnLimitR(clearPositionOnLimitR, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigClearPositionOnLimitR(self._this, clearPositionOnLimitR, timeoutMs)
end

---@param clearPositionOnQuadIdx boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configClearPositionOnQuadIdx(clearPositionOnQuadIdx, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigClearPositionOnQuadIdx(self._this, clearPositionOnQuadIdx, timeoutMs)
end

---@param limitSwitchDisableNeutralOnLOS boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configLimitSwitchDisableNeutralOnLOS(limitSwitchDisableNeutralOnLOS, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigLimitSwitchDisableNeutralOnLOS(self._this, limitSwitchDisableNeutralOnLOS, timeoutMs)
end

---@param softLimitDisableNeutralOnLOS boolean
---@param timeoutMs? integer
---@return integer
function VictorSPX:configSoftLimitDisableNeutralOnLOS(softLimitDisableNeutralOnLOS, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigSoftLimitDisableNeutralOnLOS(self._this, softLimitDisableNeutralOnLOS, timeoutMs)
end

---@param pulseWidthPeriod_EdgesPerRot integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:configPulseWidthPeriod_EdgesPerRot(pulseWidthPeriod_EdgesPerRot, timeoutMs)
    timeoutMs = timeoutMs or 0
    pulseWidthPeriod_EdgesPerRot = AssertInt(pulseWidthPeriod_EdgesPerRot)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigPulseWidthPeriod_EdgesPerRot(self._this, pulseWidthPeriod_EdgesPerRot, timeoutMs)
end

---@param pulseWidthPeriod_FilterWindowSz integer
---@param timeoutMs? integer
---@return integer
function VictorSPX:configPulseWidthPeriod_FilterWindowSz(pulseWidthPeriod_FilterWindowSz, timeoutMs)
    timeoutMs = timeoutMs or 0
    pulseWidthPeriod_FilterWindowSz = AssertInt(pulseWidthPeriod_FilterWindowSz)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.VictorSPX_ConfigPulseWidthPeriod_FilterWindowSz(self._this, pulseWidthPeriod_FilterWindowSz, timeoutMs)
end

---@return integer
function VictorSPX:getLastError()
    return ffi.C.VictorSPX_GetLastError(self._this)
end

---@return integer
function VictorSPX:getFirmwareVersion()
    return ffi.C.VictorSPX_GetFirmwareVersion(self._this)
end

---@return boolean
function VictorSPX:hasResetOccurred()
    return ffi.C.VictorSPX_HasResetOccurred(self._this)
end

---@return integer
function VictorSPX:getBaseID()
    return ffi.C.VictorSPX_GetBaseID(self._this)
end

---@return integer
function VictorSPX:getControlMode()
    return ffi.C.VictorSPX_GetControlMode(self._this)
end


---@return any
function VictorSPX:valueUpdated()
    ffi.C.VictorSPX_ValueUpdated(self._this)
end

---@return any
function VictorSPX:feed()
    ffi.C.VictorSPX_Feed(self._this)
end

---@param expirationTime number
---@return any
function VictorSPX:setExpiration(expirationTime)
    expirationTime = AssertNumber(expirationTime)
    ffi.C.VictorSPX_SetExpiration(self._this, expirationTime)
end

---@return boolean
function VictorSPX:isAlive()
    return ffi.C.VictorSPX_IsAlive(self._this)
end

---@param enabled boolean
---@return any
function VictorSPX:setSafetyEnabled(enabled)
    ffi.C.VictorSPX_SetSafetyEnabled(self._this, enabled)
end

---@return boolean
function VictorSPX:isSafetyEnabled()
    return ffi.C.VictorSPX_IsSafetyEnabled(self._this)
end

---@param deviceNumber integer
---@return any
function VictorSPX:new(deviceNumber)
    deviceNumber = AssertInt(deviceNumber)
    local instance = {
        _this = ffi.C.VictorSPX_new(deviceNumber),
    }
    setmetatable(instance, self)
    self.__index = self
    return instance
end

---@param mode integer
---@param value number
---@return any
function VictorSPX:setWithVictorSPXControlMode(mode, value)
    mode = AssertInt(mode)
    value = AssertNumber(value)
    ffi.C.VictorSPX_SetWithVictorSPXControlMode(self._this, mode, value)
end

---@param mode integer
---@param demand0 number
---@param demand1Type integer
---@param demand1 number
---@return any
function VictorSPX:setWithVictorSPXControlModeAndDemands(mode, demand0, demand1Type, demand1)
    mode = AssertInt(mode)
    demand0 = AssertNumber(demand0)
    demand1Type = AssertInt(demand1Type)
    demand1 = AssertNumber(demand1)
    ffi.C.VictorSPX_SetWithVictorSPXControlModeAndDemands(self._this, mode, demand0, demand1Type, demand1)
end

---@return number
function VictorSPX:getExpiration()
    return ffi.C.VictorSPX_GetExpiration(self._this)
end

---@return any
function TalonSRX:toSpeedController()
    return ffi.C.TalonSRX_ToSpeedController(self._this)
end

---@param value number
---@return any
function TalonSRX:set(value)
    value = AssertNumber(value)
    ffi.C.TalonSRX_Set(self._this, value)
end

---@param output number
---@return any
function TalonSRX:setVoltage(output)
    output = AssertNumber(output)
    ffi.C.TalonSRX_SetVoltage(self._this, output)
end

---@return number
function TalonSRX:get()
    return ffi.C.TalonSRX_Get(self._this)
end

---@param isInverted boolean
---@return any
function TalonSRX:setInvertedBool(isInverted)
    ffi.C.TalonSRX_SetInvertedBool(self._this, isInverted)
end

---@return boolean
function TalonSRX:getInvertedBool()
    return ffi.C.TalonSRX_GetInvertedBool(self._this)
end

---@return any
function TalonSRX:disable()
    ffi.C.TalonSRX_Disable(self._this)
end

---@return any
function TalonSRX:stopMotor()
    ffi.C.TalonSRX_StopMotor(self._this)
end

---@return any
function TalonSRX:toIMotorController()
    return ffi.C.TalonSRX_ToIMotorController(self._this)
end

---@param mode integer
---@param value number
---@return any
function TalonSRX:setWithControlMode(mode, value)
    mode = AssertInt(mode)
    value = AssertNumber(value)
    ffi.C.TalonSRX_SetWithControlMode(self._this, mode, value)
end

---@param mode integer
---@param demand0 number
---@param demand1Type integer
---@param demand1 number
---@return any
function TalonSRX:setWithControlModeAndDemands(mode, demand0, demand1Type, demand1)
    mode = AssertInt(mode)
    demand0 = AssertNumber(demand0)
    demand1Type = AssertInt(demand1Type)
    demand1 = AssertNumber(demand1)
    ffi.C.TalonSRX_SetWithControlModeAndDemands(self._this, mode, demand0, demand1Type, demand1)
end

---@return any
function TalonSRX:neutralOutput()
    ffi.C.TalonSRX_NeutralOutput(self._this)
end

---@param neutralMode integer
---@return any
function TalonSRX:setNeutralMode(neutralMode)
    neutralMode = AssertInt(neutralMode)
    ffi.C.TalonSRX_SetNeutralMode(self._this, neutralMode)
end

---@param PhaseSensor boolean
---@return any
function TalonSRX:setSensorPhase(PhaseSensor)
    ffi.C.TalonSRX_SetSensorPhase(self._this, PhaseSensor)
end

---@param invertType integer
---@return any
function TalonSRX:setInverted(invertType)
    invertType = AssertEnumValue(CTREInvertType, invertType)
    invertType = AssertInt(invertType)
    ffi.C.TalonSRX_SetInverted(self._this, invertType)
end

---@return boolean
function TalonSRX:getInverted()
    return ffi.C.TalonSRX_GetInverted(self._this)
end

---@param timeoutMs? integer
---@return integer
function TalonSRX:configFactoryDefault(timeoutMs)
    timeoutMs = timeoutMs or 50
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigFactoryDefault(self._this, timeoutMs)
end

---@param secondsFromNeutralToFull number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configOpenloopRamp(secondsFromNeutralToFull, timeoutMs)
    timeoutMs = timeoutMs or 0
    secondsFromNeutralToFull = AssertNumber(secondsFromNeutralToFull)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigOpenloopRamp(self._this, secondsFromNeutralToFull, timeoutMs)
end

---@param secondsFromNeutralToFull number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configClosedloopRamp(secondsFromNeutralToFull, timeoutMs)
    timeoutMs = timeoutMs or 0
    secondsFromNeutralToFull = AssertNumber(secondsFromNeutralToFull)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigClosedloopRamp(self._this, secondsFromNeutralToFull, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configPeakOutputForward(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigPeakOutputForward(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configPeakOutputReverse(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigPeakOutputReverse(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configNominalOutputForward(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigNominalOutputForward(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configNominalOutputReverse(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigNominalOutputReverse(self._this, percentOut, timeoutMs)
end

---@param percentDeadband number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configNeutralDeadband(percentDeadband, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentDeadband = AssertNumber(percentDeadband)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigNeutralDeadband(self._this, percentDeadband, timeoutMs)
end

---@param voltage number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configVoltageCompSaturation(voltage, timeoutMs)
    timeoutMs = timeoutMs or 0
    voltage = AssertNumber(voltage)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigVoltageCompSaturation(self._this, voltage, timeoutMs)
end

---@param filterWindowSamples integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configVoltageMeasurementFilter(filterWindowSamples, timeoutMs)
    timeoutMs = timeoutMs or 0
    filterWindowSamples = AssertInt(filterWindowSamples)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigVoltageMeasurementFilter(self._this, filterWindowSamples, timeoutMs)
end

---@param enable boolean
---@return any
function TalonSRX:enableVoltageCompensation(enable)
    ffi.C.TalonSRX_EnableVoltageCompensation(self._this, enable)
end

---@return boolean
function TalonSRX:isVoltageCompensationEnabled()
    return ffi.C.TalonSRX_IsVoltageCompensationEnabled(self._this)
end

---@return number
function TalonSRX:getBusVoltage()
    return ffi.C.TalonSRX_GetBusVoltage(self._this)
end

---@return number
function TalonSRX:getMotorOutputPercent()
    return ffi.C.TalonSRX_GetMotorOutputPercent(self._this)
end

---@return number
function TalonSRX:getMotorOutputVoltage()
    return ffi.C.TalonSRX_GetMotorOutputVoltage(self._this)
end

---@return number
function TalonSRX:getTemperature()
    return ffi.C.TalonSRX_GetTemperature(self._this)
end

---@param coefficient number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configSelectedFeedbackCoefficient(coefficient, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    coefficient = AssertNumber(coefficient)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigSelectedFeedbackCoefficient(self._this, coefficient, pidIdx, timeoutMs)
end

---@param sensorTerm integer
---@param feedbackDevice integer
---@return integer
function TalonSRX:configSensorTerm(sensorTerm, feedbackDevice)
    sensorTerm = AssertInt(sensorTerm)
    feedbackDevice = AssertInt(feedbackDevice)
    return ffi.C.TalonSRX_ConfigSensorTerm(self._this, sensorTerm, feedbackDevice)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getSelectedSensorPosition(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetSelectedSensorPosition(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getSelectedSensorVelocity(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetSelectedSensorVelocity(self._this, pidIdx)
end

---@param sensorPos number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:setSelectedSensorPosition(sensorPos, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 50
    sensorPos = AssertNumber(sensorPos)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_SetSelectedSensorPosition(self._this, sensorPos, pidIdx, timeoutMs)
end

---@param frame integer
---@param periodMs integer
---@return integer
function TalonSRX:setControlFramePeriod(frame, periodMs)
    frame = AssertInt(frame)
    periodMs = AssertInt(periodMs)
    return ffi.C.TalonSRX_SetControlFramePeriod(self._this, frame, periodMs)
end

---@param enable boolean
---@return any
function TalonSRX:overrideLimitSwitchesEnable(enable)
    ffi.C.TalonSRX_OverrideLimitSwitchesEnable(self._this, enable)
end

---@param forwardSensorLimit number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configForwardSoftLimitThreshold(forwardSensorLimit, timeoutMs)
    timeoutMs = timeoutMs or 0
    forwardSensorLimit = AssertNumber(forwardSensorLimit)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigForwardSoftLimitThreshold(self._this, forwardSensorLimit, timeoutMs)
end

---@param reverseSensorLimit number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configReverseSoftLimitThreshold(reverseSensorLimit, timeoutMs)
    timeoutMs = timeoutMs or 0
    reverseSensorLimit = AssertNumber(reverseSensorLimit)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigReverseSoftLimitThreshold(self._this, reverseSensorLimit, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configForwardSoftLimitEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigForwardSoftLimitEnable(self._this, enable, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configReverseSoftLimitEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigReverseSoftLimitEnable(self._this, enable, timeoutMs)
end

---@param enable boolean
---@return any
function TalonSRX:overrideSoftLimitsEnable(enable)
    ffi.C.TalonSRX_OverrideSoftLimitsEnable(self._this, enable)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonSRX:config_kP(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_Config_kP(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonSRX:config_kI(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_Config_kI(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonSRX:config_kD(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_Config_kD(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonSRX:config_kF(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_Config_kF(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonSRX:config_IntegralZone(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_Config_IntegralZone(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param allowableCloseLoopError number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configAllowableClosedloopError(slotIdx, allowableCloseLoopError, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    allowableCloseLoopError = AssertNumber(allowableCloseLoopError)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigAllowableClosedloopError(self._this, slotIdx, allowableCloseLoopError, timeoutMs)
end

---@param slotIdx integer
---@param iaccum number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configMaxIntegralAccumulator(slotIdx, iaccum, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    iaccum = AssertNumber(iaccum)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigMaxIntegralAccumulator(self._this, slotIdx, iaccum, timeoutMs)
end

---@param slotIdx integer
---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configClosedLoopPeakOutput(slotIdx, percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigClosedLoopPeakOutput(self._this, slotIdx, percentOut, timeoutMs)
end

---@param slotIdx integer
---@param loopTimeMs integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configClosedLoopPeriod(slotIdx, loopTimeMs, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    loopTimeMs = AssertInt(loopTimeMs)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigClosedLoopPeriod(self._this, slotIdx, loopTimeMs, timeoutMs)
end

---@param invert boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configAuxPIDPolarity(invert, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigAuxPIDPolarity(self._this, invert, timeoutMs)
end

---@param iaccum number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:setIntegralAccumulator(iaccum, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    iaccum = AssertNumber(iaccum)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_SetIntegralAccumulator(self._this, iaccum, pidIdx, timeoutMs)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getClosedLoopError(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetClosedLoopError(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getIntegralAccumulator(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetIntegralAccumulator(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getErrorDerivative(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetErrorDerivative(self._this, pidIdx)
end

---@param slotIdx integer
---@param pidIdx integer
---@return integer
function TalonSRX:selectProfileSlot(slotIdx, pidIdx)
    slotIdx = AssertInt(slotIdx)
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_SelectProfileSlot(self._this, slotIdx, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getClosedLoopTarget(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetClosedLoopTarget(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getActiveTrajectoryPosition(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetActiveTrajectoryPosition(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonSRX:getActiveTrajectoryArbFeedFwd(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonSRX_GetActiveTrajectoryArbFeedFwd(self._this, pidIdx)
end

---@param sensorUnitsPer100ms number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configMotionCruiseVelocity(sensorUnitsPer100ms, timeoutMs)
    timeoutMs = timeoutMs or 0
    sensorUnitsPer100ms = AssertNumber(sensorUnitsPer100ms)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigMotionCruiseVelocity(self._this, sensorUnitsPer100ms, timeoutMs)
end

---@param sensorUnitsPer100msPerSec number
---@param timeoutMs? integer
---@return integer
function TalonSRX:configMotionAcceleration(sensorUnitsPer100msPerSec, timeoutMs)
    timeoutMs = timeoutMs or 0
    sensorUnitsPer100msPerSec = AssertNumber(sensorUnitsPer100msPerSec)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigMotionAcceleration(self._this, sensorUnitsPer100msPerSec, timeoutMs)
end

---@param curveStrength integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configMotionSCurveStrength(curveStrength, timeoutMs)
    timeoutMs = timeoutMs or 0
    curveStrength = AssertInt(curveStrength)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigMotionSCurveStrength(self._this, curveStrength, timeoutMs)
end

---@return integer
function TalonSRX:clearMotionProfileTrajectories()
    return ffi.C.TalonSRX_ClearMotionProfileTrajectories(self._this)
end

---@return integer
function TalonSRX:getMotionProfileTopLevelBufferCount()
    return ffi.C.TalonSRX_GetMotionProfileTopLevelBufferCount(self._this)
end

---@return boolean
function TalonSRX:isMotionProfileFinished()
    return ffi.C.TalonSRX_IsMotionProfileFinished(self._this)
end

---@return boolean
function TalonSRX:isMotionProfileTopLevelBufferFull()
    return ffi.C.TalonSRX_IsMotionProfileTopLevelBufferFull(self._this)
end

---@return any
function TalonSRX:processMotionProfileBuffer()
    ffi.C.TalonSRX_ProcessMotionProfileBuffer(self._this)
end

---@param timeoutMs? integer
---@return integer
function TalonSRX:clearMotionProfileHasUnderrun(timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ClearMotionProfileHasUnderrun(self._this, timeoutMs)
end

---@param periodMs integer
---@return integer
function TalonSRX:changeMotionControlFramePeriod(periodMs)
    periodMs = AssertInt(periodMs)
    return ffi.C.TalonSRX_ChangeMotionControlFramePeriod(self._this, periodMs)
end

---@param baseTrajDurationMs integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configMotionProfileTrajectoryPeriod(baseTrajDurationMs, timeoutMs)
    timeoutMs = timeoutMs or 0
    baseTrajDurationMs = AssertInt(baseTrajDurationMs)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigMotionProfileTrajectoryPeriod(self._this, baseTrajDurationMs, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configMotionProfileTrajectoryInterpolationEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigMotionProfileTrajectoryInterpolationEnable(self._this, enable, timeoutMs)
end

---@param feedbackNotContinuous boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configFeedbackNotContinuous(feedbackNotContinuous, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigFeedbackNotContinuous(self._this, feedbackNotContinuous, timeoutMs)
end

---@param clearPositionOnLimitF boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configClearPositionOnLimitF(clearPositionOnLimitF, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigClearPositionOnLimitF(self._this, clearPositionOnLimitF, timeoutMs)
end

---@param clearPositionOnLimitR boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configClearPositionOnLimitR(clearPositionOnLimitR, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigClearPositionOnLimitR(self._this, clearPositionOnLimitR, timeoutMs)
end

---@param clearPositionOnQuadIdx boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configClearPositionOnQuadIdx(clearPositionOnQuadIdx, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigClearPositionOnQuadIdx(self._this, clearPositionOnQuadIdx, timeoutMs)
end

---@param limitSwitchDisableNeutralOnLOS boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configLimitSwitchDisableNeutralOnLOS(limitSwitchDisableNeutralOnLOS, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigLimitSwitchDisableNeutralOnLOS(self._this, limitSwitchDisableNeutralOnLOS, timeoutMs)
end

---@param softLimitDisableNeutralOnLOS boolean
---@param timeoutMs? integer
---@return integer
function TalonSRX:configSoftLimitDisableNeutralOnLOS(softLimitDisableNeutralOnLOS, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigSoftLimitDisableNeutralOnLOS(self._this, softLimitDisableNeutralOnLOS, timeoutMs)
end

---@param pulseWidthPeriod_EdgesPerRot integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configPulseWidthPeriod_EdgesPerRot(pulseWidthPeriod_EdgesPerRot, timeoutMs)
    timeoutMs = timeoutMs or 0
    pulseWidthPeriod_EdgesPerRot = AssertInt(pulseWidthPeriod_EdgesPerRot)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigPulseWidthPeriod_EdgesPerRot(self._this, pulseWidthPeriod_EdgesPerRot, timeoutMs)
end

---@param pulseWidthPeriod_FilterWindowSz integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configPulseWidthPeriod_FilterWindowSz(pulseWidthPeriod_FilterWindowSz, timeoutMs)
    timeoutMs = timeoutMs or 0
    pulseWidthPeriod_FilterWindowSz = AssertInt(pulseWidthPeriod_FilterWindowSz)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigPulseWidthPeriod_FilterWindowSz(self._this, pulseWidthPeriod_FilterWindowSz, timeoutMs)
end

---@return integer
function TalonSRX:getLastError()
    return ffi.C.TalonSRX_GetLastError(self._this)
end

---@return integer
function TalonSRX:getFirmwareVersion()
    return ffi.C.TalonSRX_GetFirmwareVersion(self._this)
end

---@return boolean
function TalonSRX:hasResetOccurred()
    return ffi.C.TalonSRX_HasResetOccurred(self._this)
end

---@return integer
function TalonSRX:getBaseID()
    return ffi.C.TalonSRX_GetBaseID(self._this)
end

---@return integer
function TalonSRX:getControlMode()
    return ffi.C.TalonSRX_GetControlMode(self._this)
end


---@return any
function TalonSRX:valueUpdated()
    ffi.C.TalonSRX_ValueUpdated(self._this)
end

---@return any
function TalonSRX:feed()
    ffi.C.TalonSRX_Feed(self._this)
end

---@param expirationTime number
---@return any
function TalonSRX:setExpiration(expirationTime)
    expirationTime = AssertNumber(expirationTime)
    ffi.C.TalonSRX_SetExpiration(self._this, expirationTime)
end

---@return boolean
function TalonSRX:isAlive()
    return ffi.C.TalonSRX_IsAlive(self._this)
end

---@param enabled boolean
---@return any
function TalonSRX:setSafetyEnabled(enabled)
    ffi.C.TalonSRX_SetSafetyEnabled(self._this, enabled)
end

---@return boolean
function TalonSRX:isSafetyEnabled()
    return ffi.C.TalonSRX_IsSafetyEnabled(self._this)
end

---@return number
function TalonSRX:getOutputCurrent()
    return ffi.C.TalonSRX_GetOutputCurrent(self._this)
end

---@return number
function TalonSRX:getStatorCurrent()
    return ffi.C.TalonSRX_GetStatorCurrent(self._this)
end

---@return number
function TalonSRX:getSupplyCurrent()
    return ffi.C.TalonSRX_GetSupplyCurrent(self._this)
end

---@param period integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configVelocityMeasurementPeriod(period, timeoutMs)
    timeoutMs = timeoutMs or 0
    period = AssertInt(period)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigVelocityMeasurementPeriod(self._this, period, timeoutMs)
end

---@param windowSize integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configVelocityMeasurementWindow(windowSize, timeoutMs)
    timeoutMs = timeoutMs or 0
    windowSize = AssertInt(windowSize)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigVelocityMeasurementWindow(self._this, windowSize, timeoutMs)
end

---@param limitSwitchSource integer
---@param normalOpenOrClose integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configForwardLimitSwitchSource(limitSwitchSource, normalOpenOrClose, timeoutMs)
    timeoutMs = timeoutMs or 0
    limitSwitchSource = AssertInt(limitSwitchSource)
    normalOpenOrClose = AssertInt(normalOpenOrClose)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigForwardLimitSwitchSource(self._this, limitSwitchSource, normalOpenOrClose, timeoutMs)
end

---@param limitSwitchSource integer
---@param normalOpenOrClose integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configReverseLimitSwitchSource(limitSwitchSource, normalOpenOrClose, timeoutMs)
    timeoutMs = timeoutMs or 0
    limitSwitchSource = AssertInt(limitSwitchSource)
    normalOpenOrClose = AssertInt(normalOpenOrClose)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigReverseLimitSwitchSource(self._this, limitSwitchSource, normalOpenOrClose, timeoutMs)
end

---@return integer
function TalonSRX:isFwdLimitSwitchClosed()
    return ffi.C.TalonSRX_IsFwdLimitSwitchClosed(self._this)
end

---@return integer
function TalonSRX:isRevLimitSwitchClosed()
    return ffi.C.TalonSRX_IsRevLimitSwitchClosed(self._this)
end

---@param deviceNumber integer
---@return any
function TalonSRX:new(deviceNumber)
    deviceNumber = AssertInt(deviceNumber)
    local instance = {
        _this = ffi.C.TalonSRX_new(deviceNumber),
    }
    setmetatable(instance, self)
    self.__index = self
    return instance
end

---@param mode integer
---@param value number
---@return any
function TalonSRX:setWithTalonSRXControlMode(mode, value)
    mode = AssertInt(mode)
    value = AssertNumber(value)
    ffi.C.TalonSRX_SetWithTalonSRXControlMode(self._this, mode, value)
end

---@param mode integer
---@param demand0 number
---@param demand1Type integer
---@param demand1 number
---@return any
function TalonSRX:setWithTalonSRXControlModeAndDemands(mode, demand0, demand1Type, demand1)
    mode = AssertInt(mode)
    demand0 = AssertNumber(demand0)
    demand1Type = AssertInt(demand1Type)
    demand1 = AssertNumber(demand1)
    ffi.C.TalonSRX_SetWithTalonSRXControlModeAndDemands(self._this, mode, demand0, demand1Type, demand1)
end

---@param feedbackDevice integer
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configSelectedFeedbackSensor(feedbackDevice, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    feedbackDevice = AssertInt(feedbackDevice)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigSelectedFeedbackSensor(self._this, feedbackDevice, pidIdx, timeoutMs)
end

---@param amps integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configPeakCurrentLimit(amps, timeoutMs)
    timeoutMs = timeoutMs or 0
    amps = AssertInt(amps)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigPeakCurrentLimit(self._this, amps, timeoutMs)
end

---@param milliseconds integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configPeakCurrentDuration(milliseconds, timeoutMs)
    timeoutMs = timeoutMs or 0
    milliseconds = AssertInt(milliseconds)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigPeakCurrentDuration(self._this, milliseconds, timeoutMs)
end

---@param amps integer
---@param timeoutMs? integer
---@return integer
function TalonSRX:configContinuousCurrentLimit(amps, timeoutMs)
    timeoutMs = timeoutMs or 0
    amps = AssertInt(amps)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonSRX_ConfigContinuousCurrentLimit(self._this, amps, timeoutMs)
end

---@param enable boolean
---@return any
function TalonSRX:enableCurrentLimit(enable)
    ffi.C.TalonSRX_EnableCurrentLimit(self._this, enable)
end

---@return number
function TalonSRX:getExpiration()
    return ffi.C.TalonSRX_GetExpiration(self._this)
end

---@return any
function TalonFX:toSpeedController()
    return ffi.C.TalonFX_ToSpeedController(self._this)
end

---@param value number
---@return any
function TalonFX:set(value)
    value = AssertNumber(value)
    ffi.C.TalonFX_Set(self._this, value)
end

---@param output number
---@return any
function TalonFX:setVoltage(output)
    output = AssertNumber(output)
    ffi.C.TalonFX_SetVoltage(self._this, output)
end

---@return number
function TalonFX:get()
    return ffi.C.TalonFX_Get(self._this)
end

---@param isInverted boolean
---@return any
function TalonFX:setInvertedBool(isInverted)
    ffi.C.TalonFX_SetInvertedBool(self._this, isInverted)
end

---@return boolean
function TalonFX:getInvertedBool()
    return ffi.C.TalonFX_GetInvertedBool(self._this)
end

---@return any
function TalonFX:disable()
    ffi.C.TalonFX_Disable(self._this)
end

---@return any
function TalonFX:stopMotor()
    ffi.C.TalonFX_StopMotor(self._this)
end

---@return any
function TalonFX:toIMotorController()
    return ffi.C.TalonFX_ToIMotorController(self._this)
end

---@param mode integer
---@param value number
---@return any
function TalonFX:setWithControlMode(mode, value)
    mode = AssertInt(mode)
    value = AssertNumber(value)
    ffi.C.TalonFX_SetWithControlMode(self._this, mode, value)
end

---@param mode integer
---@param demand0 number
---@param demand1Type integer
---@param demand1 number
---@return any
function TalonFX:setWithControlModeAndDemands(mode, demand0, demand1Type, demand1)
    mode = AssertInt(mode)
    demand0 = AssertNumber(demand0)
    demand1Type = AssertInt(demand1Type)
    demand1 = AssertNumber(demand1)
    ffi.C.TalonFX_SetWithControlModeAndDemands(self._this, mode, demand0, demand1Type, demand1)
end

---@return any
function TalonFX:neutralOutput()
    ffi.C.TalonFX_NeutralOutput(self._this)
end

---@param neutralMode integer
---@return any
function TalonFX:setNeutralMode(neutralMode)
    neutralMode = AssertInt(neutralMode)
    ffi.C.TalonFX_SetNeutralMode(self._this, neutralMode)
end

---@param PhaseSensor boolean
---@return any
function TalonFX:setSensorPhase(PhaseSensor)
    ffi.C.TalonFX_SetSensorPhase(self._this, PhaseSensor)
end

---@param invertType integer
---@return any
function TalonFX:setInverted(invertType)
    invertType = AssertEnumValue(CTREInvertType, invertType)
    invertType = AssertInt(invertType)
    ffi.C.TalonFX_SetInverted(self._this, invertType)
end

---@return boolean
function TalonFX:getInverted()
    return ffi.C.TalonFX_GetInverted(self._this)
end

---@param timeoutMs? integer
---@return integer
function TalonFX:configFactoryDefault(timeoutMs)
    timeoutMs = timeoutMs or 50
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigFactoryDefault(self._this, timeoutMs)
end

---@param secondsFromNeutralToFull number
---@param timeoutMs? integer
---@return integer
function TalonFX:configOpenloopRamp(secondsFromNeutralToFull, timeoutMs)
    timeoutMs = timeoutMs or 0
    secondsFromNeutralToFull = AssertNumber(secondsFromNeutralToFull)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigOpenloopRamp(self._this, secondsFromNeutralToFull, timeoutMs)
end

---@param secondsFromNeutralToFull number
---@param timeoutMs? integer
---@return integer
function TalonFX:configClosedloopRamp(secondsFromNeutralToFull, timeoutMs)
    timeoutMs = timeoutMs or 0
    secondsFromNeutralToFull = AssertNumber(secondsFromNeutralToFull)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigClosedloopRamp(self._this, secondsFromNeutralToFull, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonFX:configPeakOutputForward(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigPeakOutputForward(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonFX:configPeakOutputReverse(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigPeakOutputReverse(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonFX:configNominalOutputForward(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigNominalOutputForward(self._this, percentOut, timeoutMs)
end

---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonFX:configNominalOutputReverse(percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigNominalOutputReverse(self._this, percentOut, timeoutMs)
end

---@param percentDeadband number
---@param timeoutMs? integer
---@return integer
function TalonFX:configNeutralDeadband(percentDeadband, timeoutMs)
    timeoutMs = timeoutMs or 0
    percentDeadband = AssertNumber(percentDeadband)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigNeutralDeadband(self._this, percentDeadband, timeoutMs)
end

---@param voltage number
---@param timeoutMs? integer
---@return integer
function TalonFX:configVoltageCompSaturation(voltage, timeoutMs)
    timeoutMs = timeoutMs or 0
    voltage = AssertNumber(voltage)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigVoltageCompSaturation(self._this, voltage, timeoutMs)
end

---@param filterWindowSamples integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configVoltageMeasurementFilter(filterWindowSamples, timeoutMs)
    timeoutMs = timeoutMs or 0
    filterWindowSamples = AssertInt(filterWindowSamples)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigVoltageMeasurementFilter(self._this, filterWindowSamples, timeoutMs)
end

---@param enable boolean
---@return any
function TalonFX:enableVoltageCompensation(enable)
    ffi.C.TalonFX_EnableVoltageCompensation(self._this, enable)
end

---@return boolean
function TalonFX:isVoltageCompensationEnabled()
    return ffi.C.TalonFX_IsVoltageCompensationEnabled(self._this)
end

---@return number
function TalonFX:getBusVoltage()
    return ffi.C.TalonFX_GetBusVoltage(self._this)
end

---@return number
function TalonFX:getMotorOutputPercent()
    return ffi.C.TalonFX_GetMotorOutputPercent(self._this)
end

---@return number
function TalonFX:getMotorOutputVoltage()
    return ffi.C.TalonFX_GetMotorOutputVoltage(self._this)
end

---@return number
function TalonFX:getTemperature()
    return ffi.C.TalonFX_GetTemperature(self._this)
end

---@param coefficient number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configSelectedFeedbackCoefficient(coefficient, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    coefficient = AssertNumber(coefficient)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigSelectedFeedbackCoefficient(self._this, coefficient, pidIdx, timeoutMs)
end

---@param sensorTerm integer
---@param feedbackDevice integer
---@return integer
function TalonFX:configSensorTerm(sensorTerm, feedbackDevice)
    sensorTerm = AssertInt(sensorTerm)
    feedbackDevice = AssertInt(feedbackDevice)
    return ffi.C.TalonFX_ConfigSensorTerm(self._this, sensorTerm, feedbackDevice)
end

---@param pidIdx? integer
---@return number
function TalonFX:getSelectedSensorPosition(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetSelectedSensorPosition(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonFX:getSelectedSensorVelocity(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetSelectedSensorVelocity(self._this, pidIdx)
end

---@param sensorPos number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonFX:setSelectedSensorPosition(sensorPos, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 50
    sensorPos = AssertNumber(sensorPos)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_SetSelectedSensorPosition(self._this, sensorPos, pidIdx, timeoutMs)
end

---@param frame integer
---@param periodMs integer
---@return integer
function TalonFX:setControlFramePeriod(frame, periodMs)
    frame = AssertInt(frame)
    periodMs = AssertInt(periodMs)
    return ffi.C.TalonFX_SetControlFramePeriod(self._this, frame, periodMs)
end

---@param enable boolean
---@return any
function TalonFX:overrideLimitSwitchesEnable(enable)
    ffi.C.TalonFX_OverrideLimitSwitchesEnable(self._this, enable)
end

---@param forwardSensorLimit number
---@param timeoutMs? integer
---@return integer
function TalonFX:configForwardSoftLimitThreshold(forwardSensorLimit, timeoutMs)
    timeoutMs = timeoutMs or 0
    forwardSensorLimit = AssertNumber(forwardSensorLimit)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigForwardSoftLimitThreshold(self._this, forwardSensorLimit, timeoutMs)
end

---@param reverseSensorLimit number
---@param timeoutMs? integer
---@return integer
function TalonFX:configReverseSoftLimitThreshold(reverseSensorLimit, timeoutMs)
    timeoutMs = timeoutMs or 0
    reverseSensorLimit = AssertNumber(reverseSensorLimit)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigReverseSoftLimitThreshold(self._this, reverseSensorLimit, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configForwardSoftLimitEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigForwardSoftLimitEnable(self._this, enable, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configReverseSoftLimitEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigReverseSoftLimitEnable(self._this, enable, timeoutMs)
end

---@param enable boolean
---@return any
function TalonFX:overrideSoftLimitsEnable(enable)
    ffi.C.TalonFX_OverrideSoftLimitsEnable(self._this, enable)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonFX:config_kP(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_Config_kP(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonFX:config_kI(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_Config_kI(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonFX:config_kD(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_Config_kD(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonFX:config_kF(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_Config_kF(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param value number
---@param timeoutMs? integer
---@return integer
function TalonFX:config_IntegralZone(slotIdx, value, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    value = AssertNumber(value)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_Config_IntegralZone(self._this, slotIdx, value, timeoutMs)
end

---@param slotIdx integer
---@param allowableCloseLoopError number
---@param timeoutMs? integer
---@return integer
function TalonFX:configAllowableClosedloopError(slotIdx, allowableCloseLoopError, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    allowableCloseLoopError = AssertNumber(allowableCloseLoopError)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigAllowableClosedloopError(self._this, slotIdx, allowableCloseLoopError, timeoutMs)
end

---@param slotIdx integer
---@param iaccum number
---@param timeoutMs? integer
---@return integer
function TalonFX:configMaxIntegralAccumulator(slotIdx, iaccum, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    iaccum = AssertNumber(iaccum)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigMaxIntegralAccumulator(self._this, slotIdx, iaccum, timeoutMs)
end

---@param slotIdx integer
---@param percentOut number
---@param timeoutMs? integer
---@return integer
function TalonFX:configClosedLoopPeakOutput(slotIdx, percentOut, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    percentOut = AssertNumber(percentOut)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigClosedLoopPeakOutput(self._this, slotIdx, percentOut, timeoutMs)
end

---@param slotIdx integer
---@param loopTimeMs integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configClosedLoopPeriod(slotIdx, loopTimeMs, timeoutMs)
    timeoutMs = timeoutMs or 0
    slotIdx = AssertInt(slotIdx)
    loopTimeMs = AssertInt(loopTimeMs)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigClosedLoopPeriod(self._this, slotIdx, loopTimeMs, timeoutMs)
end

---@param invert boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configAuxPIDPolarity(invert, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigAuxPIDPolarity(self._this, invert, timeoutMs)
end

---@param iaccum number
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonFX:setIntegralAccumulator(iaccum, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    iaccum = AssertNumber(iaccum)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_SetIntegralAccumulator(self._this, iaccum, pidIdx, timeoutMs)
end

---@param pidIdx? integer
---@return number
function TalonFX:getClosedLoopError(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetClosedLoopError(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonFX:getIntegralAccumulator(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetIntegralAccumulator(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonFX:getErrorDerivative(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetErrorDerivative(self._this, pidIdx)
end

---@param slotIdx integer
---@param pidIdx integer
---@return integer
function TalonFX:selectProfileSlot(slotIdx, pidIdx)
    slotIdx = AssertInt(slotIdx)
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_SelectProfileSlot(self._this, slotIdx, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonFX:getClosedLoopTarget(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetClosedLoopTarget(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonFX:getActiveTrajectoryPosition(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetActiveTrajectoryPosition(self._this, pidIdx)
end

---@param pidIdx? integer
---@return number
function TalonFX:getActiveTrajectoryArbFeedFwd(pidIdx)
    pidIdx = pidIdx or 0
    pidIdx = AssertInt(pidIdx)
    return ffi.C.TalonFX_GetActiveTrajectoryArbFeedFwd(self._this, pidIdx)
end

---@param sensorUnitsPer100ms number
---@param timeoutMs? integer
---@return integer
function TalonFX:configMotionCruiseVelocity(sensorUnitsPer100ms, timeoutMs)
    timeoutMs = timeoutMs or 0
    sensorUnitsPer100ms = AssertNumber(sensorUnitsPer100ms)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigMotionCruiseVelocity(self._this, sensorUnitsPer100ms, timeoutMs)
end

---@param sensorUnitsPer100msPerSec number
---@param timeoutMs? integer
---@return integer
function TalonFX:configMotionAcceleration(sensorUnitsPer100msPerSec, timeoutMs)
    timeoutMs = timeoutMs or 0
    sensorUnitsPer100msPerSec = AssertNumber(sensorUnitsPer100msPerSec)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigMotionAcceleration(self._this, sensorUnitsPer100msPerSec, timeoutMs)
end

---@param curveStrength integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configMotionSCurveStrength(curveStrength, timeoutMs)
    timeoutMs = timeoutMs or 0
    curveStrength = AssertInt(curveStrength)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigMotionSCurveStrength(self._this, curveStrength, timeoutMs)
end

---@return integer
function TalonFX:clearMotionProfileTrajectories()
    return ffi.C.TalonFX_ClearMotionProfileTrajectories(self._this)
end

---@return integer
function TalonFX:getMotionProfileTopLevelBufferCount()
    return ffi.C.TalonFX_GetMotionProfileTopLevelBufferCount(self._this)
end

---@return boolean
function TalonFX:isMotionProfileFinished()
    return ffi.C.TalonFX_IsMotionProfileFinished(self._this)
end

---@return boolean
function TalonFX:isMotionProfileTopLevelBufferFull()
    return ffi.C.TalonFX_IsMotionProfileTopLevelBufferFull(self._this)
end

---@return any
function TalonFX:processMotionProfileBuffer()
    ffi.C.TalonFX_ProcessMotionProfileBuffer(self._this)
end

---@param timeoutMs? integer
---@return integer
function TalonFX:clearMotionProfileHasUnderrun(timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ClearMotionProfileHasUnderrun(self._this, timeoutMs)
end

---@param periodMs integer
---@return integer
function TalonFX:changeMotionControlFramePeriod(periodMs)
    periodMs = AssertInt(periodMs)
    return ffi.C.TalonFX_ChangeMotionControlFramePeriod(self._this, periodMs)
end

---@param baseTrajDurationMs integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configMotionProfileTrajectoryPeriod(baseTrajDurationMs, timeoutMs)
    timeoutMs = timeoutMs or 0
    baseTrajDurationMs = AssertInt(baseTrajDurationMs)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigMotionProfileTrajectoryPeriod(self._this, baseTrajDurationMs, timeoutMs)
end

---@param enable boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configMotionProfileTrajectoryInterpolationEnable(enable, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigMotionProfileTrajectoryInterpolationEnable(self._this, enable, timeoutMs)
end

---@param feedbackNotContinuous boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configFeedbackNotContinuous(feedbackNotContinuous, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigFeedbackNotContinuous(self._this, feedbackNotContinuous, timeoutMs)
end

---@param clearPositionOnLimitF boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configClearPositionOnLimitF(clearPositionOnLimitF, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigClearPositionOnLimitF(self._this, clearPositionOnLimitF, timeoutMs)
end

---@param clearPositionOnLimitR boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configClearPositionOnLimitR(clearPositionOnLimitR, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigClearPositionOnLimitR(self._this, clearPositionOnLimitR, timeoutMs)
end

---@param clearPositionOnQuadIdx boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configClearPositionOnQuadIdx(clearPositionOnQuadIdx, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigClearPositionOnQuadIdx(self._this, clearPositionOnQuadIdx, timeoutMs)
end

---@param limitSwitchDisableNeutralOnLOS boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configLimitSwitchDisableNeutralOnLOS(limitSwitchDisableNeutralOnLOS, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigLimitSwitchDisableNeutralOnLOS(self._this, limitSwitchDisableNeutralOnLOS, timeoutMs)
end

---@param softLimitDisableNeutralOnLOS boolean
---@param timeoutMs? integer
---@return integer
function TalonFX:configSoftLimitDisableNeutralOnLOS(softLimitDisableNeutralOnLOS, timeoutMs)
    timeoutMs = timeoutMs or 0
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigSoftLimitDisableNeutralOnLOS(self._this, softLimitDisableNeutralOnLOS, timeoutMs)
end

---@param pulseWidthPeriod_EdgesPerRot integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configPulseWidthPeriod_EdgesPerRot(pulseWidthPeriod_EdgesPerRot, timeoutMs)
    timeoutMs = timeoutMs or 0
    pulseWidthPeriod_EdgesPerRot = AssertInt(pulseWidthPeriod_EdgesPerRot)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigPulseWidthPeriod_EdgesPerRot(self._this, pulseWidthPeriod_EdgesPerRot, timeoutMs)
end

---@param pulseWidthPeriod_FilterWindowSz integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configPulseWidthPeriod_FilterWindowSz(pulseWidthPeriod_FilterWindowSz, timeoutMs)
    timeoutMs = timeoutMs or 0
    pulseWidthPeriod_FilterWindowSz = AssertInt(pulseWidthPeriod_FilterWindowSz)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigPulseWidthPeriod_FilterWindowSz(self._this, pulseWidthPeriod_FilterWindowSz, timeoutMs)
end

---@return integer
function TalonFX:getLastError()
    return ffi.C.TalonFX_GetLastError(self._this)
end

---@return integer
function TalonFX:getFirmwareVersion()
    return ffi.C.TalonFX_GetFirmwareVersion(self._this)
end

---@return boolean
function TalonFX:hasResetOccurred()
    return ffi.C.TalonFX_HasResetOccurred(self._this)
end

---@return integer
function TalonFX:getBaseID()
    return ffi.C.TalonFX_GetBaseID(self._this)
end

---@return integer
function TalonFX:getControlMode()
    return ffi.C.TalonFX_GetControlMode(self._this)
end


---@return any
function TalonFX:valueUpdated()
    ffi.C.TalonFX_ValueUpdated(self._this)
end

---@return any
function TalonFX:feed()
    ffi.C.TalonFX_Feed(self._this)
end

---@param expirationTime number
---@return any
function TalonFX:setExpiration(expirationTime)
    expirationTime = AssertNumber(expirationTime)
    ffi.C.TalonFX_SetExpiration(self._this, expirationTime)
end

---@return boolean
function TalonFX:isAlive()
    return ffi.C.TalonFX_IsAlive(self._this)
end

---@param enabled boolean
---@return any
function TalonFX:setSafetyEnabled(enabled)
    ffi.C.TalonFX_SetSafetyEnabled(self._this, enabled)
end

---@return boolean
function TalonFX:isSafetyEnabled()
    return ffi.C.TalonFX_IsSafetyEnabled(self._this)
end

---@return number
function TalonFX:getOutputCurrent()
    return ffi.C.TalonFX_GetOutputCurrent(self._this)
end

---@return number
function TalonFX:getStatorCurrent()
    return ffi.C.TalonFX_GetStatorCurrent(self._this)
end

---@return number
function TalonFX:getSupplyCurrent()
    return ffi.C.TalonFX_GetSupplyCurrent(self._this)
end

---@param period integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configVelocityMeasurementPeriod(period, timeoutMs)
    timeoutMs = timeoutMs or 0
    period = AssertInt(period)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigVelocityMeasurementPeriod(self._this, period, timeoutMs)
end

---@param windowSize integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configVelocityMeasurementWindow(windowSize, timeoutMs)
    timeoutMs = timeoutMs or 0
    windowSize = AssertInt(windowSize)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigVelocityMeasurementWindow(self._this, windowSize, timeoutMs)
end

---@param limitSwitchSource integer
---@param normalOpenOrClose integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configForwardLimitSwitchSource(limitSwitchSource, normalOpenOrClose, timeoutMs)
    timeoutMs = timeoutMs or 0
    limitSwitchSource = AssertInt(limitSwitchSource)
    normalOpenOrClose = AssertInt(normalOpenOrClose)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigForwardLimitSwitchSource(self._this, limitSwitchSource, normalOpenOrClose, timeoutMs)
end

---@param limitSwitchSource integer
---@param normalOpenOrClose integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configReverseLimitSwitchSource(limitSwitchSource, normalOpenOrClose, timeoutMs)
    timeoutMs = timeoutMs or 0
    limitSwitchSource = AssertInt(limitSwitchSource)
    normalOpenOrClose = AssertInt(normalOpenOrClose)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigReverseLimitSwitchSource(self._this, limitSwitchSource, normalOpenOrClose, timeoutMs)
end

---@return integer
function TalonFX:isFwdLimitSwitchClosed()
    return ffi.C.TalonFX_IsFwdLimitSwitchClosed(self._this)
end

---@return integer
function TalonFX:isRevLimitSwitchClosed()
    return ffi.C.TalonFX_IsRevLimitSwitchClosed(self._this)
end

---@param deviceNumber integer
---@return any
function TalonFX:new(deviceNumber)
    deviceNumber = AssertInt(deviceNumber)
    local instance = {
        _this = ffi.C.TalonFX_new(deviceNumber),
    }
    setmetatable(instance, self)
    self.__index = self
    return instance
end

---@param mode integer
---@param value number
---@return any
function TalonFX:setWithTalonFXControlMode(mode, value)
    mode = AssertInt(mode)
    value = AssertNumber(value)
    ffi.C.TalonFX_SetWithTalonFXControlMode(self._this, mode, value)
end

---@param mode integer
---@param demand0 number
---@param demand1Type integer
---@param demand1 number
---@return any
function TalonFX:setWithTalonFXControlModeAndDemands(mode, demand0, demand1Type, demand1)
    mode = AssertInt(mode)
    demand0 = AssertNumber(demand0)
    demand1Type = AssertInt(demand1Type)
    demand1 = AssertNumber(demand1)
    ffi.C.TalonFX_SetWithTalonFXControlModeAndDemands(self._this, mode, demand0, demand1Type, demand1)
end

---@param invertType integer
---@return any
function TalonFX:setInvertedTalonFX(invertType)
    invertType = AssertEnumValue(CTRETalonFXInvertType, invertType)
    invertType = AssertInt(invertType)
    ffi.C.TalonFX_SetInvertedTalonFX(self._this, invertType)
end

---@param enable boolean
---@param currentLimit number
---@return any
function TalonFX:configStatorCurrentLimit(enable, currentLimit)
    currentLimit = AssertNumber(currentLimit)
    ffi.C.TalonFX_ConfigStatorCurrentLimit(self._this, enable, currentLimit)
end

---@param offsetDegrees number
---@param timeoutMs? integer
---@return any
function TalonFX:configIntegratedSensorOffset(offsetDegrees, timeoutMs)
    timeoutMs = timeoutMs or 0
    offsetDegrees = AssertNumber(offsetDegrees)
    timeoutMs = AssertInt(timeoutMs)
    ffi.C.TalonFX_ConfigIntegratedSensorOffset(self._this, offsetDegrees, timeoutMs)
end

---@param feedbackDevice integer
---@param pidIdx? integer
---@param timeoutMs? integer
---@return integer
function TalonFX:configSelectedFeedbackSensor(feedbackDevice, pidIdx, timeoutMs)
    pidIdx = pidIdx or 0
    timeoutMs = timeoutMs or 0
    feedbackDevice = AssertInt(feedbackDevice)
    pidIdx = AssertInt(pidIdx)
    timeoutMs = AssertInt(timeoutMs)
    return ffi.C.TalonFX_ConfigSelectedFeedbackSensor(self._this, feedbackDevice, pidIdx, timeoutMs)
end

---@return number
function TalonFX:getExpiration()
    return ffi.C.TalonFX_GetExpiration(self._this)
end

---@param deviceID integer
---@param type integer
---@return any
function CANSparkMax:new(deviceID, type)
    type = AssertEnumValue(SparkMaxMotorType, type)
    deviceID = AssertInt(deviceID)
    type = AssertInt(type)
    local instance = {
        _this = ffi.C.CANSparkMax_new(deviceID, type),
    }
    setmetatable(instance, self)
    self.__index = self
    return instance
end

---@param type integer
---@return any
function CANSparkMax:setIdleMode(type)
    type = AssertEnumValue(IdleMode, type)
    type = AssertInt(type)
    ffi.C.CANSparkMax_SetIdleMode(self._this, type)
end

---@return any
function CANSparkMax:restoreFactoryDefaults()
    ffi.C.CANSparkMax_RestoreFactoryDefaults(self._this)
end

---@param speed number
---@return any
function CANSparkMax:set(speed)
    speed = AssertNumber(speed)
    ffi.C.CANSparkMax_Set(self._this, speed)
end

---@param output number
---@return any
function CANSparkMax:setVoltage(output)
    output = AssertNumber(output)
    ffi.C.CANSparkMax_SetVoltage(self._this, output)
end

---@return number
function CANSparkMax:get()
    return ffi.C.CANSparkMax_Get(self._this)
end

---@param isInverted boolean
---@return any
function CANSparkMax:setInverted(isInverted)
    ffi.C.CANSparkMax_SetInverted(self._this, isInverted)
end

---@return boolean
function CANSparkMax:getInverted()
    return ffi.C.CANSparkMax_GetInverted(self._this)
end

---@return any
function CANSparkMax:disable()
    ffi.C.CANSparkMax_Disable(self._this)
end

---@return any
function CANSparkMax:stopMotor()
    ffi.C.CANSparkMax_StopMotor(self._this)
end



---@param encoder any
---@return number
function CANSparkMax:getPosition(encoder)
    return ffi.C.CANSparkMax_GetPosition(self._this, encoder)
end

---@param position number
---@param countsPerRev? integer
---@return any
function CANSparkMax:setPosition(position, countsPerRev)
    countsPerRev = countsPerRev or 42
    position = AssertNumber(position)
    countsPerRev = AssertInt(countsPerRev)
    ffi.C.CANSparkMax_SetPosition(self._this, position, countsPerRev)
end

---@return number
function SparkMaxRelativeEncoder:getPosition()
    return ffi.C.SparkMaxRelativeEncoder_GetPosition(self._this)
end

---@return number
function SparkMaxRelativeEncoder:getVelocity()
    return ffi.C.SparkMaxRelativeEncoder_GetVelocity(self._this)
end


---@param xSpeed number
---@param zRotation number
---@param squareInputs boolean
---@return any
function DifferentialDrive:arcadeDrive(xSpeed, zRotation, squareInputs)
    xSpeed = AssertNumber(xSpeed)
    zRotation = AssertNumber(zRotation)
    ffi.C.DifferentialDrive_ArcadeDrive(self._this, xSpeed, zRotation, squareInputs)
end

---@param leftSpeed number
---@param rightSpeed number
---@param squareInputs boolean
---@return any
function DifferentialDrive:tankDrive(leftSpeed, rightSpeed, squareInputs)
    leftSpeed = AssertNumber(leftSpeed)
    rightSpeed = AssertNumber(rightSpeed)
    ffi.C.DifferentialDrive_TankDrive(self._this, leftSpeed, rightSpeed, squareInputs)
end

